Android Training Logs
20130506

so -- shared object
dll -- dynamic link library

Librares are located on /system/lib/
such as libwebcore.so, libril.so
but surface manager is a exception.

JVM -- dalvik virtual machine
each app has it own Dalvik VM instance.
the source is located in android/dalvik

libc --- C library, is located in android/bionic

both bionic and dalvik contain important functions.

android/device/asus/grouper  --> Nexus7 

android/external  --> contain a lot of open source projects.
AOSP -- android opensource project
HAL -- hardware abstraction layer

android/libcore -- JAVA library developed by apache harmony, not sun or oracle.

in this lecture we only focus on 4 directories: bionic, dalvik, framework, system.

we use vim+ctags to analyse source code.
$ctags *
ctags file contain all the function and variable lables.
open vim to edit a file, choose a function, press ctrl+] to the func, press ctrl+t to return.
To build the ctags database: $ctags -R bionic/ dalvik/ frameworks/ system/

init is located in android-2.2.x/system/core/init, it's the first process to start when boot Android system.

Power on
-> CPU reset
-> Bootloader: Hardware checking & initializtion
			   Kernel & RAMdisk loading
-> Linux kernel
-> init (ex: System-V init, Upstart init ...)

Types

zygote is the base process responsible for start all the Android services.
it's the parent process of all the JAVA services.

make -j(# of CPUs)
make -j(# of CPUs * 2)
make -j(# of CPUs + 2)

make -j2
make -j4

----------------------------------

init.rc include two parts: Action(commands) and Service(deamons)
Actions --> 1.early init, 2.init, 3.early-boot, 4.boot
Services --> a lots of...

init process monitor all the child process, if the child process go to zombie and exit, the init will decide whether to recreate or kill it.

<TODAY ASSIMENTS>
1. Building the 4.2.x platform source for the emulator.
2. Study vim editor.(ctags usage)
3. Read chapter 1 of ebook "Embedded Android".

=========================================
20130507

boot.img (bootloader + kernel)
source ./buildsetup.sh
lunch
emulator (use the output image by default)

start the emulator with the img we build last night for android-4.2.2
copy userdata.img(104K) -->  userdata-qemu.img(12M) when emulator start, the size becomes larger. it's located in /data directory in the device.
ramdisk.img  -- root file system.
system.img  -- android things, lib,service.read-only, /system directory in the device
userdata.img -- read-write,

password of the pdf: droid4x or jb422

android stage driver introduce:
BINDER
lowmemorykiller  -- how does it know who should be killed? by what standard?
The anwser is by "ADJ value" which define the priority of the process. Please check figure 3-8 in page 20 of "03. The init process.pdf".
Memory thresholds value: when the mem is above(bigger) the value, mem killer will kill it.

logger

keep going on study init process.
Property service:
similiar to enviroment variable, Name = Value
Each process has its own environment variable in its memroy area.
One process can't change the environment variable of other process.
But property could be accessed by other processes, it's located in shared memory area. All the modification requested by process will be transfer to init process to change the property value. General process don't have permission to change it.


init process register SIGCHILD signal, once the kernel call SIGCHILD to hang up a process, the init can recieve it. 
sigaction(SIGCHLD, &act, 0);

Create basic filesystem:
/dev
/sys/
/proc

/dev/pts contain virtual terminal device file. It's means how many times you log in with shell.
/dev/socket contain the socket file node. property_service can be only modified by init process.
All the /dev/socket file is Unix Domain Socket.(it's different with TCP/IP socket)

Logging device

init.rc parsing

After parse_config_file("/init.rc"), action lists and service lists are created. 

socketpair() create two connected sockets.Only use Unix Domain Socket for internal communication(can be seen by AF_UNIX and SOCK_STREAM).

Other process send SIGCHILD to init, then init call: SOCKET A(signal_fd) ----> SOCKET B(signal_recv_fd), to pass the event to SIG detection.

Three file descriptors should be noted: device_fd, property_set_fd, signal_recv_fd in init.c.
device_fd --- recieved when new device is detected
property_set_fd  -- recieved when the other process send the property change request.
signal_recv_fd   -- recieved when child process terminate

"class_start default" in init.rc : this line start the services of "default" class.
############################
###  Action ################
############################
=============================
#############################
#### Service ################
#############################


on property:ro.kernel.qemu=1  //it means if(ro.kernel.qemu == 1)
	start adbd				  // then        start adbd;

servicemanager has a name context manager

init process will enter "recovery" mode when some serious problem occur.

service servicemanager /system/bin/servicemanager
	user system		// user is system
	critical		// means it's should be restart if it's dead
	onrestart restart zygote    // should restart zygote when it's restart
	onrestart restart media     // same as above


service bootanim /system/bin/bootanimation
	user graphics
	group graphics
	disabled
	oneshot		// oneshot means should be runing only once after the device boot

android/system/core/init/readme.txt has the info of init.c and init.rc, worth to read.


3.4 Device node creation
Note that some device node such as binder should be created staticly. Because when the kernel start, the init process is not lunched.

The device detection is not same after android2.3:
After Android2.3(gingerbread), use udev to replace init to detect new device.
	ueventd.goldfish.rc
	ueventd.rc	// defines the device node that should be created staticly

Before android 2.3:
device ---> init ---> /dev/node

After android 2.3:
device ---> ueventd ---> /dev/node

3.5 Process termination and restart

3.6 Property service
_system_property_area_ is created by init_property_area() with ASHMEM method.

================================
04. JNI & NDK
JNIEXPORT and JNICALL are only for windows, in linux we don't need these keyword.
JNICALL means function calling convention. 
JNIEXPORT void JNICALL Java_HelloJNI_printHello(JNIEnv *, jobject);

<TODAY ASSIMENTS>
1. Compile the Android Platform source for Nexus 7.
2. Read Chapter 2 of "Embedded Android".
3. 

<MY QUESTION>
1. why does .so is bigger than .o, what's the contents inside.
2. notice extern "C"
3. Nexus 7 include some non-open-source library. need to extract first before compiling.


20130508
1. 编译Nexus7原生内核。
2. JNIHello源码讲解。
JAVA  String 2bytes
------------------------
C/C++ jstring(char) 1byte

(*env)->GetStringUTFChars(env, string, 0); 调用jni指针函数可以转换

 g++ -Wall -fPIC -c jnifunc.cpp -I /home/student/jdk6/include/ -I /home/student/jdk6/include/linux/
-Wall : warn all 
-fPIC : to generate "position independent code"

g++ -shared -Wl,-soname=libjnifunc.so -o libjnifunc.so jnifunc.o
-Wl,-soname=libjnifunc.so : 把-soname=libjnifunc.so传递给linker,这个选项只会被linker识别，GCC/G++不识别。
-Wl,option1,option2 (pass to linker)
-Wa,option1,option2 (pass to assembler)
-Wp,option1,option2 ()

Ctags只能记住function and global varaiable.不能记住local varirable。
本地变量用"gd"搜索定义，"``"返回。
Ctags用"Ctrl+]"搜索定义，“Ctrl+t”返回。

C++中调用JAVA类的方法：1.获取class,2.获取class ID,3.NewObject调用构造函数
24     // Find the class for object creation
25     targetClass = env->FindClass("JniTest");
26     // Get the constructor method ID
27     mid = env->GetMethodID(targetClass, "<init>", "(I)V");
28     // Create a Java object
29     printf("[CPP] JniTest object created\n");
30     newObject = env->NewObject(targetClass, mid, 100);

C调用JAVA函数。

JAVA调CPP，通过JNI。

为啥要学习JNI
1. 学习Android platform
2. 写APP用得到。

SDK : JAVA
NDK : JAVA + C/C++

用eclipse写APP的时候，libs/android-support-v4.jar library的目的是让老版本的APP能够顺利运行在新版本库上。
AndroidManifest.xml --- APP的配置文件，向android环境提供运行平台信息，版本信息，permission信息等等。
生成文件在bin/res/Hello.apk

JNI native function name: Java_com_example_hellojni_HelloJni_stringFromJNI
Java_<package name>_<class name>_ownname();

<TODAY ASSIGNMENT>
1. Compile the Android platform source.(again, for the emulator, but with different combination)
2. Read "The JAVA Native Interface(1999)".
3.Read chapter 4 of "Embedded Android", to know what's the meaning of LOCAL_PATH := $(call my-dir)
	include $(CLEAR_VARS)


20130509
学习了fork, execl。
学习app_main.cpp，了解zygote process是怎么启动的。
set_process_name("zygote"); 改变了进程名，由app_process --> zygote
执行了source ./build/envsetup.sh 之后，会包括很多有用的命令。如godir, cgrep, croot可以到android根目录。

class name --> com.android.internal.os.ZygoteInit
				com/android/internal/os/ZygoteInit
 jclass = env->FindClass(className)

method name --> main()
	jmethodID = env->GetStaticMethodID(jclass, "main", "([Ljava/lang/String;)V");

     (JAVA system service)     (C++)
	      SystemServer ---> SurfaceFlinger(Native System Service)
              |
            Zygote
         \|/
        init
          |  
		kernel

runtime->callStatic("com/android/server/SystemServer", "init2");
//means go back to JAVA space，创建完Native Service surfaceflinger，返回JAVA空间。调用init2，开启ServerThread.

5.3.4
下面讲如何通过Zygote运行起来一个新的APP。
通过socket通信。select/poll监听client事件。

<Practice - Embedded Applications>
把APP添加进/system/app，用eclipse建立一个新的APP工程MyApp，并在手机上验证通过。
删除APP源码中的bin, gen目录。将MyApp目录拷贝到android/packages/apps。
在android根目录执行source ./build/envsetup.sh
lunch full-userdebug
到app目录执行mm, 在out下生成apk。
最后为了集成到system.img中，在android目录执行m,但是发现system.img没有更新。因此需要用以下命令生成：
m snod
snod = System image with No Dependency checking

Android PDK

=====================
Android APP
每个app都会包含以下四个部分：
- Activity : Output(UI) + Input
- Service : Background processing
- (Broadcast) Receiver : Event processing
- (Content) Provider : Data sharing


Manifest 
- (n) The list of components

             [Activity]        [Service]
			StartService() --> onCreate()
			StopService()       ...
			                   StopSelf()

			[Activity]
								  [Service]
			BindService <========>	
			UnbindService<=======>

	原始概念的RPC call通过TCP/IP socket传送数据。
	[Computer A]			[Computer B]
	res=add(10,20)			add(i, j)
	   |	/\				{
	   \/	|					****			   
	add(m, n)				}   /\  |
	{	(Proxy)	    (TCP/IP)	 |  \/
		RPC socket  ------>   RPC socket(Stub) 
	}			   <----------------|				-

IDL(interface definition language)
	IDL compiler ==> Proxy & Stub code auto-generated!
	"Marshalling", "Unmashalling"
	Crosses process boundary using Binder communication.

AIDL(Android interface definition language)
	 AIDL compiler ==> Proxy & Stub code auto-generated!
	 "Marshalling", "Unmashalling"
	Crosses process boundary using Binder communication.


